/*
 * PROJECT:   Mouri Internal Library Essentials
 * FILE:      Mile.NtCrt.Uefi.Stubs.cpp
 * PURPOSE:   Stubs for Windows Driver Kit C Runtime for UEFI
 *
 * LICENSE:   The MIT License
 *
 * MAINTAINER: MouriNaruto (Kenji.Mouri@outlook.com)
 */

namespace
{
    int g_errno = 0;
}

extern "C" int* __cdecl _errno()
{
    return &g_errno;
}

extern "C" void __cdecl _invalid_parameter_noinfo()
{
    // Do nothing.
}

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64 uintptr_t;
#else
typedef unsigned int uintptr_t;
#endif
#endif

extern "C" void __cdecl _invalid_parameter(
    wchar_t const* const expression,
    wchar_t const* const function_name,
    wchar_t const* const file_name,
    unsigned int const line_number,
    uintptr_t const reserved)
{
    expression;
    function_name;
    file_name;
    line_number;
    reserved;
}

extern "C" __declspec(noreturn) void __cdecl __report_gsfailure(
    uintptr_t stack_cookie)
{
    stack_cookie;
    for (;;) {}
}

__pragma(comment(linker, "/alternatename:__lookuptable_s=__lookuptable"));

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef _W64 unsigned int size_t;
#endif
#define _SIZE_T_DEFINED
#endif

typedef int errno_t;

#ifndef EINVAL
#define EINVAL 22
#endif // !EINVAL

#ifndef ERANGE
#define ERANGE 34
#endif // !ERANGE

#ifndef EILSEQ
#define EILSEQ 42
#endif // !EILSEQ

// Generated by Microsoft Copilot for temporary workaround.
extern "C" errno_t __cdecl wctomb_s(
    int* const return_value,
    char* const destination,
    size_t const destination_count,
    wchar_t const wchar) {

    if (destination == nullptr || destination_count == 0) {
        if (return_value != nullptr) {
            *return_value = -1;
        }
        return EINVAL;
    }

    if (return_value != nullptr) {
        *return_value = 0;
    }

    if (wchar < 0x80) {
        if (destination_count < 1) return ERANGE;
        destination[0] = (char)wchar;
        if (return_value != nullptr) *return_value = 1;
        return 0;
    }
    else if (wchar < 0x800) {
        if (destination_count < 2) return ERANGE;
        destination[0] = (char)(0xC0 | (wchar >> 6));
        destination[1] = (char)(0x80 | (wchar & 0x3F));
        if (return_value != nullptr) *return_value = 2;
        return 0;
    }
    else if (wchar < 0x10000) {
        if (destination_count < 3) return ERANGE;
        destination[0] = (char)(0xE0 | (wchar >> 12));
        destination[1] = (char)(0x80 | ((wchar >> 6) & 0x3F));
        destination[2] = (char)(0x80 | (wchar & 0x3F));
        if (return_value != nullptr) *return_value = 3;
        return 0;
    }
    else if (wchar >= 0xD800 && wchar <= 0xDBFF) {
        return EILSEQ;  // Leading surrogate
    }
    else if (wchar >= 0xDC00 && wchar <= 0xDFFF) {
        return EILSEQ;  // Trailing surrogate
    }
    else if (wchar < 0x110000) {
        if (destination_count < 4) return ERANGE;

        // Encode surrogate pair
        unsigned int codepoint =
            0x10000 + ((wchar - 0xD800) << 10) + (wchar - 0xDC00);
        destination[0] = (char)(0xF0 | (codepoint >> 18));
        destination[1] = (char)(0x80 | ((codepoint >> 12) & 0x3F));
        destination[2] = (char)(0x80 | ((codepoint >> 6) & 0x3F));
        destination[3] = (char)(0x80 | (codepoint & 0x3F));
        if (return_value != nullptr) *return_value = 4;
        return 0;
    }
    else {
        return EILSEQ;
    }
}

// Generated by Microsoft Copilot for temporary workaround.
extern "C" int __cdecl mbtowc(
    wchar_t* pwc,
    const char* s,
    size_t n)
{
    if (s == nullptr) {
        return 0;
    }

    const unsigned char* us = (const unsigned char*)s;
    wchar_t wc = 0;
    int length = 0;

    if (us[0] < 0x80) {
        wc = us[0];
        length = 1;
    }
    else if ((us[0] & 0xE0) == 0xC0) {
        if (n < 2 || (us[1] & 0xC0) != 0x80) return -1;
        wc = ((us[0] & 0x1F) << 6) | (us[1] & 0x3F);
        length = 2;
    }
    else if ((us[0] & 0xF0) == 0xE0) {
        if (n < 3 || (us[1] & 0xC0) != 0x80 || (us[2] & 0xC0) != 0x80) return -1;
        wc = ((us[0] & 0x0F) << 12) | ((us[1] & 0x3F) << 6) | (us[2] & 0x3F);
        length = 3;
    }
    else if ((us[0] & 0xF8) == 0xF0) {
        if (n < 4 || (us[1] & 0xC0) != 0x80 || (us[2] & 0xC0) != 0x80 || (us[3] & 0xC0) != 0x80) return -1;
        wc = ((us[0] & 0x07) << 18) | ((us[1] & 0x3F) << 12) | ((us[2] & 0x3F) << 6) | (us[3] & 0x3F);
        length = 4;
    }
    else {
        return -1;
    }

    if (pwc != nullptr) {
        *pwc = wc;
    }
    return length;
}
